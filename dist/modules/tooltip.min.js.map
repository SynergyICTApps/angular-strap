{"version":3,"sources":["tooltip.min.js","tooltip/tooltip.js"],"names":["angular","module","provider","defaults","this","animation","customClass","prefixClass","prefixEvent","container","target","placement","template","contentTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","$get","$window","$rootScope","$compile","$q","$templateCache","$http","$animate","$sce","dimensions","$$rAF","$timeout","TooltipFactory","element","config","enterAnimateCallback","scope","$emit","options","$tooltip","leaveAnimateCallback","_blur","blur","destroyTipElement","bindTriggerEvents","triggers","split","forEach","on","toggle","enter","leave","nodeName","isTouch","$onFocusElementMouseDown","unbindTriggerEvents","i","length","off","bindKeyboardEvents","tipElement","$onKeyUp","$onFocusKeyUp","unbindKeyboardEvents","bindAutoCloseEvents","stopEventPropagation","$body","hide","_autoCloseEventsBinded","unbindAutoCloseEvents","event","stopPropagation","getPosition","$element","el","elRect","getBoundingClientRect","width","extend","right","left","height","bottom","top","elPos","offset","position","getCalculatedOffset","actualWidth","actualHeight","applyPlacementCss","css","clearTimeout","timeout","$isShown","tipScope","$destroy","remove","toLowerCase","$options","$promise","fetchTemplate","$scope","$new","isString","map","parseFloat","trustAsHtml","$setEnabled","isEnabled","$$postDigest","setEnabled","$hide","$show","$toggle","hoverState","then","templateEl","contentEl","findElement","removeAttr","outerHTML","tipLinker","tipTemplate","tipContainer","isObject","data","replace","htmlReplaceRegExp","trim","apply","init","isNumber","isElement","focus","destroy","setTimeout","parent","after","lastChild","clonedElement","display","visibility","addClass","promise","safeDigest","$applyPlacement","autoToken","autoPlace","test","elementPosition","tipWidth","prop","tipHeight","originalPlacement","document","querySelector","containerPosition","indexOf","removeClass","tipPosition","evt","which","preventDefault","$$phase","$root","$digest","query","querySelectorAll","fetchPromises","when","get","res","put","String","prototype","directive","$location","restrict","link","attr","transclusion","key","isDefined","$observe","newValue","oldValue","tooltip","bsTooltip","$watch","bsShow","match","$on"],"mappings":"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","file":"tooltip.min.js","sourcesContent":[null,"'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function() {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      template: 'tooltip/tooltip.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0,\r\n      autoClose: false,\r\n      bsEnabled: true\r\n    };\r\n\r\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\r\n\r\n      var trim = String.prototype.trim;\r\n      var isTouch = 'createTouch' in $window.document;\r\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\r\n      var $body = angular.element($window.document);\r\n\r\n      function TooltipFactory(element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        $tooltip.$promise = fetchTemplate(options.template);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n        if(options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Support scope as string options\r\n        if(options.title) {\r\n          scope.title = $sce.trustAsHtml(options.title);\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$setEnabled = function(isEnabled) {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.setEnabled(isEnabled);\r\n          });\r\n        };\r\n        scope.$hide = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout, hoverState;\r\n\r\n        // Support contentTemplate option\r\n        if(options.contentTemplate) {\r\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\r\n            var templateEl = angular.element(template);\r\n            return fetchTemplate(options.contentTemplate)\r\n            .then(function(contentTemplate) {\r\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\r\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\r\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\r\n              return templateEl[0].outerHTML;\r\n            });\r\n          });\r\n        }\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\r\n        $tooltip.$promise.then(function(template) {\r\n          if(angular.isObject(template)) template = template.data;\r\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\r\n          template = trim.apply(template);\r\n          tipTemplate = template;\r\n          tipLinker = $compile(template);\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function() {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if(options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if(angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if(options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          bindTriggerEvents();\r\n\r\n          // Options: target\r\n          if(options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if(options.show) {\r\n            scope.$$postDigest(function() {\r\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function() {\r\n\r\n          // Unbind events\r\n          unbindTriggerEvents();\r\n\r\n          // Remove element\r\n          destroyTipElement();\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function() {\r\n            if (hoverState ==='in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function() {\r\n          if (!options.bsEnabled) return;\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          var parent, after;\r\n          if (options.container) {\r\n            parent = tipContainer;\r\n            if (tipContainer[0].lastChild) {\r\n              after = angular.element(tipContainer[0].lastChild);\r\n            } else {\r\n              after = null;\r\n            }\r\n          } else {\r\n            parent = null;\r\n            after = element;\r\n          }\r\n\r\n\r\n          // Hide any existing tipElement\r\n          if(tipElement) destroyTipElement();\r\n          // Fetch a cloned element linked from template\r\n          tipScope = $tooltip.$scope.$new();\r\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'});\r\n\r\n          // Options: animation\r\n          if(options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if(options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          if(promise && promise.then) promise.then(enterAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          safeDigest(scope);\r\n          $$rAF(function () {\r\n            $tooltip.$applyPlacement();\r\n\r\n            // Once placed, make the tooltip visible\r\n            if(tipElement) tipElement.css({visibility: 'visible'});\r\n          }); // var a = bodyEl.offsetWidth + 1; ?\r\n\r\n          // Bind events\r\n          if(options.keyboard) {\r\n            if(options.trigger !== 'focus') {\r\n              $tooltip.focus();\r\n            }\r\n            bindKeyboardEvents();\r\n          }\r\n\r\n          if(options.autoClose) {\r\n            bindAutoCloseEvents();\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n        }\r\n\r\n        $tooltip.leave = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        var _blur;\r\n        $tooltip.hide = function(blur) {\r\n\r\n          if(!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n\r\n          // store blur value for leaveAnimateCallback to use\r\n          _blur = blur;\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\r\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          safeDigest(scope);\r\n\r\n          // Unbind events\r\n          if(options.keyboard && tipElement !== null) {\r\n            unbindKeyboardEvents();\r\n          }\r\n\r\n          if(options.autoClose && tipElement !== null) {\r\n            unbindAutoCloseEvents();\r\n          }\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          // Allow to blur the input when hidden, like when pressing enter key\r\n          if(_blur && options.trigger === 'focus') {\r\n            return element[0].blur();\r\n          }\r\n\r\n          // clean up child scopes\r\n          destroyTipElement();\r\n        }\r\n\r\n        $tooltip.toggle = function() {\r\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\r\n        };\r\n\r\n        $tooltip.focus = function() {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        $tooltip.setEnabled = function(isEnabled) {\r\n          options.bsEnabled = isEnabled;\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function() {\r\n          if(!tipElement) return;\r\n\r\n          // Determine if we're doing an auto or normal placement\r\n          var placement = options.placement,\r\n              autoToken = /\\s?auto?\\s?/i,\r\n              autoPlace  = autoToken.test(placement);\r\n\r\n          if (autoPlace) {\r\n            placement = placement.replace(autoToken, '') || defaults.placement;\r\n          }\r\n\r\n          // Need to add the position class before we get\r\n          // the offsets\r\n          tipElement.addClass(options.placement);\r\n\r\n          // Get the position of the target element\r\n          // and the height and width of the tooltip so we can center it.\r\n          var elementPosition = getPosition(),\r\n              tipWidth = tipElement.prop('offsetWidth'),\r\n              tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // If we're auto placing, we need to check the positioning\r\n          if (autoPlace) {\r\n            var originalPlacement = placement;\r\n            var container = options.container ? angular.element(document.querySelector(options.container)) : element.parent();\r\n            var containerPosition = getPosition(container);\r\n\r\n            // Determine if the vertical placement\r\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\r\n              placement = originalPlacement.replace('bottom', 'top');\r\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\r\n              placement = originalPlacement.replace('top', 'bottom');\r\n            }\r\n\r\n            // Determine the horizontal placement\r\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\r\n            // and flow in the opposite direction of their placement.\r\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\r\n                elementPosition.right + tipWidth > containerPosition.width) {\r\n\r\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\r\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\r\n                elementPosition.left - tipWidth < containerPosition.left) {\r\n\r\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\r\n            }\r\n\r\n            tipElement.removeClass(originalPlacement).addClass(placement);\r\n          }\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\r\n          applyPlacementCss(tipPosition.top, tipPosition.left);\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function(evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function(evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function(evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\r\n        };\r\n\r\n        // bind/unbind events\r\n        function bindTriggerEvents() {\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function(trigger) {\r\n            if(trigger === 'click') {\r\n              element.on('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          });\r\n        }\r\n\r\n        function unbindTriggerEvents() {\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if(trigger === 'click') {\r\n              element.off('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          }\r\n        }\r\n\r\n        function bindKeyboardEvents() {\r\n          if(options.trigger !== 'focus') {\r\n            tipElement.on('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.on('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        function unbindKeyboardEvents() {\r\n          if(options.trigger !== 'focus') {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          } else {\r\n            element.off('keyup', $tooltip.$onFocusKeyUp);\r\n          }\r\n        }\r\n\r\n        var _autoCloseEventsBinded = false;\r\n        function bindAutoCloseEvents() {\r\n          // use timeout to hookup the events to prevent\r\n          // event bubbling from being processed imediately.\r\n          $timeout(function() {\r\n            // Stop propagation when clicking inside tooltip\r\n            tipElement.on('click', stopEventPropagation);\r\n\r\n            // Hide when clicking outside tooltip\r\n            $body.on('click', $tooltip.hide);\r\n\r\n            _autoCloseEventsBinded = true;\r\n          }, 0, false);\r\n        }\r\n\r\n        function unbindAutoCloseEvents() {\r\n          if (_autoCloseEventsBinded) {\r\n            tipElement.off('click', stopEventPropagation);\r\n            $body.off('click', $tooltip.hide);\r\n            _autoCloseEventsBinded = false;\r\n          }\r\n        }\r\n\r\n        function stopEventPropagation(event) {\r\n          event.stopPropagation();\r\n        }\r\n\r\n        // Private methods\r\n\r\n        function getPosition($element) {\r\n          $element = $element || (options.target || element);\r\n\r\n          var el = $element[0];\r\n\r\n          var elRect = el.getBoundingClientRect();\r\n          if (elRect.width === null) {\r\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\r\n            elRect = angular.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\r\n          }\r\n\r\n          var elPos;\r\n          if (options.container === 'body') {\r\n            elPos = dimensions.offset(el);\r\n          } else {\r\n            elPos = dimensions.position(el);\r\n          }\r\n\r\n          return angular.extend({}, elRect, elPos);\r\n        }\r\n\r\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n          case 'right':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left + position.width\r\n            };\r\n            break;\r\n          case 'bottom':\r\n            offset = {\r\n              top: position.top + position.height,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          case 'left':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left - actualWidth\r\n            };\r\n            break;\r\n          default:\r\n            offset = {\r\n              top: position.top - actualHeight,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          }\r\n\r\n          if(!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if(split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n            case 'left':\r\n              offset.left = position.left;\r\n              break;\r\n            case 'right':\r\n              offset.left =  position.left + position.width - actualWidth;\r\n            }\r\n          } else if(split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n            case 'top':\r\n              offset.top = position.top - actualHeight;\r\n              break;\r\n            case 'bottom':\r\n              offset.top = position.top + position.height;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        function applyPlacementCss(top, left) {\r\n          tipElement.css({ top: top + 'px', left: left + 'px' });\r\n        }\r\n\r\n        function destroyTipElement() {\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          if($tooltip.$isShown && tipElement !== null) {\r\n            if(options.autoClose) {\r\n              unbindAutoCloseEvents();\r\n            }\r\n\r\n            if(options.keyboard) {\r\n              unbindKeyboardEvents();\r\n            }\r\n          }\r\n\r\n          if(tipScope) {\r\n            tipScope.$destroy();\r\n            tipScope = null;\r\n          }\r\n\r\n          if(tipElement) {\r\n            tipElement.remove();\r\n            tipElement = $tooltip.$element = null;\r\n          }\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function safeDigest(scope) {\r\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n      }\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      var fetchPromises = {};\r\n      function fetchTemplate(template) {\r\n        if(fetchPromises[template]) return fetchPromises[template];\r\n        return (fetchPromises[template] = $q.when($templateCache.get(template) || $http.get(template))\r\n        .then(function(res) {\r\n          if(angular.isObject(res)) {\r\n            $templateCache.put(template, res.data);\r\n            return res.data;\r\n          }\r\n          return res;\r\n        }));\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'backdropAnimation', 'type', 'customClass'], function(key) {\r\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // overwrite inherited title value when no value specified\r\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\r\n        if (!scope.title){\r\n          scope.title = '';\r\n        }\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function(newValue) {\r\n          if (angular.isDefined(newValue) || !scope.title) {\r\n            var oldValue = scope.title;\r\n            scope.title = $sce.trustAsHtml(newValue);\r\n            angular.isDefined(oldValue) && $$rAF(function() {\r\n              tooltip && tooltip.$applyPlacement();\r\n            });\r\n          }\r\n        });\r\n\r\n        // Support scope as an object\r\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\r\n          if(angular.isObject(newValue)) {\r\n            angular.extend(scope, newValue);\r\n          } else {\r\n            scope.title = newValue;\r\n          }\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        }, true);\r\n\r\n        // Visibility binding support\r\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\r\n          newValue === true ? tooltip.show() : tooltip.hide();\r\n        });\r\n\r\n        // Enabled binding support\r\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\r\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\r\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\r\n        });\r\n\r\n        // Initialize popover\r\n        var tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function() {\r\n          if(tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n"],"sourceRoot":"/source/"}